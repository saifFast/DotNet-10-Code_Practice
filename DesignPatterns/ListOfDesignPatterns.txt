==========================================================
SOFTWARE DESIGN PATTERNS - CATEGORIZED LIST
==========================================================

----------------------------
CREATIONAL PATTERNS
----------------------------
1. Singleton
   - Ensures a class has only one instance and provides a global access point to it.

2. Factory Method
   - Defines an interface for creating an object but allows subclasses to alter the type of objects that will be created.

3. Abstract Factory
   - Provides an interface to create families of related or dependent objects without specifying their concrete classes.

4. Builder
   - Separates the construction of a complex object from its representation so that the same construction process can create different representations.

5. Prototype
   - Creates new objects by copying an existing object (the prototype).

----------------------------
STRUCTURAL PATTERNS
----------------------------
1. Adapter
   - Allows incompatible interfaces to work together by wrapping one interface with another.

2. Bridge
   - Decouples an abstraction from its implementation so the two can vary independently.

3. Composite
   - Composes objects into tree structures to represent part-whole hierarchies.

4. Decorator
   - Dynamically adds responsibilities to an object without altering its structure.

5. Facade
   - Provides a simplified interface to a complex subsystem.

6. Flyweight
   - Reduces memory usage by sharing common data between similar objects.

7. Proxy
   - Provides a surrogate or placeholder for another object to control access to it.

----------------------------
BEHAVIORAL PATTERNS
----------------------------
1. Chain of Responsibility
   - Passes a request along a chain of handlers until one of them handles it.

2. Command
   - Encapsulates a request as an object, allowing parameterization of clients with different requests.

3. Interpreter
   - Defines a representation for a language’s grammar and an interpreter to interpret sentences in the language.

4. Iterator
   - Provides a way to access elements of a collection sequentially without exposing its underlying structure.

5. Mediator
   - Defines an object that encapsulates how a set of objects interact.

6. Memento
   - Captures and restores an object's internal state without violating encapsulation.

7. Observer
   - Defines a one-to-many dependency so that when one object changes state, all its dependents are notified automatically.

8. State
   - Allows an object to alter its behavior when its internal state changes.

9. Strategy
   - Defines a family of algorithms, encapsulates each one, and makes them interchangeable.

10. Template Method
    - Defines the skeleton of an algorithm in a method, deferring some steps to subclasses.

11. Visitor
    - Separates an algorithm from the object structure on which it operates.

==========================================================
END OF LIST
==========================================================
